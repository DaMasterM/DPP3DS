// Fill out your copyright notice in the Description page of Project Settings.


#include "PRM.h"
#include "Runtime/Engine/Classes/Kismet/GameplayStatics.h"
#include "Kismet/KismetSystemLibrary.h"
#include "DrawDebugHelpers.h"
#include "BasicRoom.h"

// Sets default values
APRM::APRM()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = false;

}

// Called when the game starts or when spawned
void APRM::BeginPlay() { Super::BeginPlay(); }

// Called every frame
void APRM::Tick(float DeltaTime) { Super::Tick(DeltaTime); }

void APRM::removePRM() {
	vertices.Empty();
	edges.Empty();
}

void APRM::calculateWeights() {
	//Reset the weights array
	weights.Empty();

	//Create a separate array for the weights such that calculations can happen later
	TArray<float> tempWeights;
	float surfaceSize = 0;

	//Calculate the weights of the surface area relative to each other
	for (ASurfaceArea* surfaceArea : surfaces) {
		// Add the weight of the cube to the array and to the total
		tempWeights.Add(surfaceArea->totalSize);
		surfaceSize += surfaceArea->totalSize;
	}
	
	// Go over the weights array and divide the weights by the total area size
	for (float weight : tempWeights) {
		weight = weight / surfaceSize;
		weights.Add(weight);
	}

	totalSize = surfaceSize;
}

void APRM::hidePRM() {
	for (AVertex* vertex : vertices) { if (vertex) { vertex->hideVertex(); } }
	for (APRMEdge* edge : edges) { if (edge) { edge->hideEdge(); } }
}

void APRM::showPRM() {
	for (AVertex* vertex : vertices) { if (vertex) { vertex->showVertex(); } }
	for (APRMEdge* edge : edges) { if (edge) { edge->showEdge(); } }
}

float APRM::calculateCoverSize(float agentSize) { 
	float returnValue = 0;

	//Calculate the cover size of each surface and add it to the result
	for (ASurfaceArea* surface : surfaces) { returnValue += surface->calculateCoverSize(agentSize); }

	return returnValue;
}

void APRM::setVertexCount(float inverseVertexDensity) {
	vertexCount = (totalSize * inverseVertexDensity);

	//If the vertex count is 0, force it back to 1 so that a vertex is always created on a surface
	if (vertexCount == 0) { vertexCount = 1; }

	//Set the amount of vertices to connect using k-nearest neighbours, which is half the vertex count with a minimum of 2 (if possible to have two connections)
	edgeCount = vertexCount / 2;
	edgeCount = FMath::Max(edgeCount, 2);

}

int32 APRM::generateRandomVertices(int32 startID, float agentSize, bool apsmo, bool assmo) {
	//ID for the new vertex
	int32 newID = startID;
	int32 verticesGenerated = 0;

	//Optional: generate at least one vertex on every subsurface
	if (assmo) {
		//Find all surfaces
		for (ASurfaceArea* surface : surfaces) {

			//Find all subsurfaces of a surface
			for (int i = 0; i < surface->cubes.Num(); i++) {

				//Try to generate a new vertex. If a new one is generated, count it towards the amount of vertices generated by this option
				int32 oldID = newID;
				newID = generateVertexInSubsurface(newID, surface, i, agentSize);
				if (oldID != newID) { verticesGenerated++; }
			}
		}
	}

	//Optional: generate at least one vertex on every partial surface. Won't be done if assmo is true since this case would have technically been handled already
	if (!assmo && apsmo) {
		for (ASurfaceArea* surface : surfaces) {

			//Try to generate a new vertex. If a new one is generated, count it towards the amount of vertices generated by this option
			int32 oldID = newID;
			newID = generateVertex(newID, surface, agentSize);
			if (oldID != newID) { verticesGenerated++; }
		}
	}

	// Loop until vertexCount vertices have been created, if the optional stuff beforehand didn't do so already.
	// Do note that we TRY to create vertexCount vertices. If one cannot be generated, we generate one less.
	for (int i = verticesGenerated; i < vertexCount; i++) {
		//Find a surface to generate a vertex on
		ASurfaceArea* selectedSurface = selectRandomSurface();

		//Generate the vertex
		newID = generateVertex(newID, selectedSurface, agentSize);
	}

	return newID;
}

int32 APRM::generateApproximateMedialVertices(int32 startID, float agentSize)
{
	//ID for the new vertex
	int32 newID = startID;
	int32 verticesGenerated = 0;
	FVector location = FVector(0);

	// Loop until vertexCount vertices have been created, if the optional stuff beforehand didn't do so already.
	// Do note that we TRY to create vertexCount vertices. If one cannot be generated, we generate one less.
	for (int i = verticesGenerated; i < vertexCount; i++) {
		//Find a location on a surface to generate a vertex on
		ASurfaceArea* selectedSurface = selectRandomSurface();

		if (selectedSurface) {
			UStaticMeshComponent* selectedCube = selectedSurface->getRandomCube();

			if (selectedCube) { location = selectedSurface->getRandomSpawnLocation(selectedCube);  }
		}

		//Move this location towards the medial axis
		bool canGenerate = false;
		location = approximateMedialAxis(location, selectedSurface, agentSize, canGenerate);

		//Generate the vertex
		if (canGenerate) { newID = generateVertexAtLocation(newID, selectedSurface, location, agentSize); }
	}

	return newID;
}

int32 APRM::generateExactMedialVertices(int32 startID, float agentSize)
{//ID for the new vertex
	int32 newID = startID;
	int32 verticesGenerated = 0;
	FVector location = FVector(0);

	// Loop until vertexCount vertices have been created, if the optional stuff beforehand didn't do so already.
	// Do note that we TRY to create vertexCount vertices. If one cannot be generated, we generate one less.
	for (int i = verticesGenerated; i < vertexCount; i++) {
		//Find a location on a surface to generate a vertex on
		ASurfaceArea* selectedSurface = selectRandomSurface();

		if (selectedSurface) { location = selectedSurface->getRandomSkeletonLocation(); }
		
		newID = generateVertexAtLocation(newID, selectedSurface, location, agentSize);
	}

	return newID;
}

FVector APRM::approximateMedialAxis(FVector inLocation, ASurfaceArea* surface, float agentSize, bool &canGenerate)
{
	//Ensure that the locations given are relative to the surface's center, else we get p.X = 1000, q.X = -4000, r.X = 6000, so way out of bounds!
	FVector returnValue = inLocation - surface->GetActorLocation();
	//DrawDebugPoint(GetWorld(), inLocation, 20, FColor::Red, false, 60, 0);

	//Ensure that inLocation is inside the polygon
	if (surface->polygon.isInsidePolygon(inLocation, surface->surface)) {
		//Find the nearest obstacle and the helper location
		FVector obstacleLocation = findClosestObstacle(inLocation, surface) - surface->GetActorLocation();
		//DrawDebugPoint(GetWorld(), obstacleLocation + surface->GetActorLocation() , 20, FColor::Green, false, 60, 0);
		FVector helperLocation = 2 * returnValue - obstacleLocation;
		//DrawDebugPoint(GetWorld(), helperLocation + surface->GetActorLocation(), 20, FColor::Blue, false, 60, 0);

		//In order to prevent the system from thinking there can be an infinite loop
		int32 moves = 0;

		//Move the location for the new vertex towards the medial axis
		while (moves < 100 && surface->polygon.isInsidePolygon(helperLocation + surface->GetActorLocation(), surface->surface)) {
			// p = (p+r)/2; r = 2p - q;
			returnValue = (returnValue + helperLocation) / 2;
			//DrawDebugPoint(GetWorld(), returnValue + surface->GetActorLocation(), 20, FColor::Yellow, false, 60, 0);
			helperLocation = 2 * returnValue - obstacleLocation;
			//DrawDebugPoint(GetWorld(), helperLocation + surface->GetActorLocation(), 20, FColor::Cyan, false, 60, 0);
			moves++;
		}

		//Ensure that the found location is inside the polygon. If so, we can generate a vertex here.
		if (surface->polygon.isInsidePolygon(returnValue + surface->GetActorLocation(), surface->surface)){
			canGenerate = true;
			returnValue += surface->GetActorLocation();
			//DrawDebugPoint(GetWorld(), returnValue, 20, FColor::Magenta, false, 60, 0);
		}
	}
	//If inLocation is not inside the polygon, then the algorithm won't work, so don't generate a point
	else { canGenerate = false; }

	return returnValue;
}

FVector APRM::findClosestObstacle(FVector location, ASurfaceArea* surface)
{
	//Return value and the end points of all traces
	FVector returnValue = FVector(0);
	FVector traceNorthEnd = FVector(0);
	FVector traceSouthEnd = FVector(0);
	FVector traceEastEnd = FVector(0);
	FVector traceWestEnd = FVector(0);
	
	//Prepare the line traces
	FHitResult northHit; FHitResult southHit; FHitResult eastHit; FHitResult westHit;
	FHitResult cornerHit;

	//Actors to ignore
	TArray<AActor*> ignores;

	//Object types to trace
	TArray<TEnumAsByte<EObjectTypeQuery>> traceObjectTypes;
	traceObjectTypes.Add(UEngineTypes::ConvertToObjectType(ECollisionChannel::ECC_WorldStatic));

	//Set the extent of the vertex in the directions parallel to the surface. Also set the directional trace end locations]
	switch (surface->surface) {
	case ESurfaceType::Ceiling:
		traceNorthEnd = location + FVector(10000, 0, 0);
		traceSouthEnd = location - FVector(10000, 0, 0);
		traceEastEnd = location + FVector(0, 10000, 0);
		traceWestEnd = location - FVector(0, 10000, 0);
		break;
	case ESurfaceType::Floor:
		traceNorthEnd = location + FVector(10000, 0, 0);
		traceSouthEnd = location - FVector(10000, 0, 0);
		traceEastEnd = location + FVector(0, 10000, 0);
		traceWestEnd = location - FVector(0, 10000, 0);
		break;
	case ESurfaceType::Stairs:
		traceNorthEnd = location + FVector(10000, 0, 0);
		traceSouthEnd = location - FVector(10000, 0, 0);
		traceEastEnd = location + FVector(0, 10000, 0);
		traceWestEnd = location - FVector(0, 10000, 0);
		break;
	case ESurfaceType::StairsCeiling:
		traceNorthEnd = location + FVector(10000, 0, 0);
		traceSouthEnd = location - FVector(10000, 0, 0);
		traceEastEnd = location + FVector(0, 10000, 0);
		traceWestEnd = location - FVector(0, 10000, 0);
		break;
	case ESurfaceType::NorthWall:
		traceNorthEnd = location + FVector(0, 0, 10000);
		traceSouthEnd = location - FVector(0, 0, 10000);
		traceEastEnd = location + FVector(0, 10000, 0);
		traceWestEnd = location - FVector(0, 10000, 0);
		break;
	case ESurfaceType::SouthWall:
		traceNorthEnd = location + FVector(0, 0, 10000);
		traceSouthEnd = location - FVector(0, 0, 10000);
		traceEastEnd = location + FVector(0, 10000, 0);
		traceWestEnd = location - FVector(0, 10000, 0);
		break;
	case ESurfaceType::EastWall:
		traceNorthEnd = location + FVector(10000, 0, 0);
		traceSouthEnd = location - FVector(10000, 0, 0);
		traceEastEnd = location + FVector(0, 0, 10000);
		traceWestEnd = location - FVector(0, 0, 10000);
		break;
	case ESurfaceType::WestWall:
		traceNorthEnd = location + FVector(10000, 0, 0);
		traceSouthEnd = location - FVector(10000, 0, 0);
		traceEastEnd = location + FVector(0, 0, 10000);
		traceWestEnd = location - FVector(0, 0, 10000);
		break;
	default:
		break;
	}

	UKismetSystemLibrary::LineTraceSingleByProfile(GetWorld(), location, traceNorthEnd, "EdgeTraceBlocker", false, ignores, EDrawDebugTrace::None, northHit, true, FLinearColor::Yellow, FLinearColor::White, 60);
	UKismetSystemLibrary::LineTraceSingleByProfile(GetWorld(), location, traceSouthEnd, "EdgeTraceBlocker", false, ignores, EDrawDebugTrace::None, southHit, true, FLinearColor::Yellow, FLinearColor::White, 60);
	UKismetSystemLibrary::LineTraceSingleByProfile(GetWorld(), location, traceEastEnd, "EdgeTraceBlocker", false, ignores, EDrawDebugTrace::None, eastHit, true, FLinearColor::Yellow, FLinearColor::White, 60);
	UKismetSystemLibrary::LineTraceSingleByProfile(GetWorld(), location, traceWestEnd, "EdgeTraceBlocker", false, ignores, EDrawDebugTrace::None, westHit, true, FLinearColor::Yellow, FLinearColor::White, 60);

	//Find the trace hit with the shortest distance
	float shortestDistance = 999999;

	if (northHit.Actor != nullptr) { returnValue = northHit.ImpactPoint; shortestDistance = northHit.Distance; }
	if (southHit.Actor != nullptr) { if (southHit.Distance < shortestDistance) { returnValue = southHit.ImpactPoint; shortestDistance = southHit.Distance; } }
	if (eastHit.Actor != nullptr) { if (eastHit.Distance < shortestDistance) { returnValue = eastHit.ImpactPoint; shortestDistance = eastHit.Distance; } }
	if (westHit.Actor != nullptr) { if (westHit.Distance < shortestDistance) { returnValue = westHit.ImpactPoint; shortestDistance = westHit.Distance; } }

	for (FVector vertex : surface->polygon.vertices3D) {
		UKismetSystemLibrary::LineTraceSingleByProfile(GetWorld(), location, vertex, "EdgeTraceBlocker", false, ignores, EDrawDebugTrace::None, cornerHit, true, FLinearColor::Yellow, FLinearColor::White, 60);
		if (cornerHit.Actor != nullptr) { if (cornerHit.Distance < shortestDistance) { returnValue = cornerHit.ImpactPoint; shortestDistance = cornerHit.Distance; } }
	}

	return returnValue;
}

bool APRM::checkNeighbouringSurfaces(AVertex * base, AVertex * neighbour)
{
	bool baseInSurface = false;
	bool neighbourInSurface = false; 

	//Hit check array
	TArray<FHitResult> overlapsBase;
	TArray<FHitResult> overlapsNeighbour;

	//Actors to ignore, so the surface itself
	TArray<AActor*> ignores;
	ignores.Add(this);

	//Object types to trace
	TArray<TEnumAsByte<EObjectTypeQuery>> traceObjectTypes;
	traceObjectTypes.Add(UEngineTypes::ConvertToObjectType(ECollisionChannel::ECC_WorldStatic));

	//Find the surfaces of the two vertices
	UKismetSystemLibrary::BoxTraceMultiForObjects(GetWorld(), base->GetActorLocation(), base->GetActorLocation(), FVector(5), FRotator(0), traceObjectTypes, false, ignores, EDrawDebugTrace::None, overlapsBase, true, FLinearColor::Green, FLinearColor::Red, 60); 
	UKismetSystemLibrary::BoxTraceMultiForObjects(GetWorld(), neighbour->GetActorLocation(), neighbour->GetActorLocation(), FVector(5), FRotator(0), traceObjectTypes, false, ignores, EDrawDebugTrace::None, overlapsNeighbour, true, FLinearColor::Green, FLinearColor::Red, 60);

	ASurfaceArea* baseSurface = nullptr;
	ASurfaceArea* neighbourSurface = nullptr;
	UStaticMeshComponent* baseSubsurface = nullptr;
	UStaticMeshComponent* neighbourSubsurface = nullptr;

	//Find the subsurfaces the two vertices are in
	for (FHitResult hit : overlapsBase) {
		AActor* baseSurfaceActor = hit.GetActor();
		if (baseSurfaceActor->GetClass() == ASurfaceArea::StaticClass()) {
			baseSurface = (ASurfaceArea*)baseSurfaceActor;
			if (hit.GetComponent()->GetClass() == UStaticMeshComponent::StaticClass()) { baseSubsurface = (UStaticMeshComponent*)hit.GetComponent(); }
		}
	}
	for (FHitResult hit : overlapsNeighbour) {
		AActor* neighbourSurfaceActor = hit.GetActor();
		if (neighbourSurfaceActor->GetClass() == ASurfaceArea::StaticClass()) {
			neighbourSurface = (ASurfaceArea*)neighbourSurfaceActor;
			if (hit.GetComponent()->GetClass() == UStaticMeshComponent::StaticClass()) { neighbourSubsurface = (UStaticMeshComponent*)hit.GetComponent(); }
		}
	}
	
	//Check if these subsurfaces are neighbours
	if (baseSurface != nullptr) { for (FSurfaceNeighbour surfaceNeighbour : baseSurface->neighbours) {
		if (surfaceNeighbour.cube == baseSubsurface && surfaceNeighbour.neighbourID == neighbourSurface->id) { baseInSurface = true; }
	}}
	if (neighbourSurface != nullptr) { for (FSurfaceNeighbour surfaceNeighbour : neighbourSurface->neighbours) {
		if (surfaceNeighbour.cube == neighbourSubsurface && surfaceNeighbour.neighbourID == baseSurface->id) { neighbourInSurface = true; }
	}}

	return baseInSurface && neighbourInSurface;
}

bool APRM::checkIfInSurface(AVertex * vertex, ASurfaceArea * surface)
{
	//Output array
	TArray<AActor*> overlaps;

	//Actors to ignore, so the surface itself
	TArray<AActor*> ignores;
	ignores.Add(this);

	//Object types to trace
	TArray<TEnumAsByte<EObjectTypeQuery>> traceObjectTypes;
	traceObjectTypes.Add(UEngineTypes::ConvertToObjectType(ECollisionChannel::ECC_WorldStatic));

	//Find the surfaces of the two vertices
	UKismetSystemLibrary::BoxOverlapActors(GetWorld(), vertex->GetActorLocation(), FVector(5), traceObjectTypes, ASurfaceArea::StaticClass(), ignores, overlaps);

	if (overlaps.Contains(surface)) { return true; }
	return false;
}

ASurfaceArea* APRM::selectRandomSurface() {
	//The surface area that will be returned
	ASurfaceArea* returnValue = nullptr;

	//Find a random number between 0 and 1
	float random = FMath::FRandRange(0, 1);

	//Create an array with the sum of the weights per surface, so surface A has weight a, B has a + b, etc. Last surface has a + b + ... = 1.
	TArray<float> sumOfWeights;

	for (int i = 0; i < weights.Num(); i++) {
		float sumWeight = weights[i];

		//Except for the first item, add the weight of the previous sum
		if (i > 0) { sumWeight += sumOfWeights[i - 1]; }
		sumOfWeights.Add(sumWeight);
	}

	//Then select the lowest index j such that random <= weight at j
	for (int j = 0; j < sumOfWeights.Num(); j++) {
		if (random <= sumOfWeights[j]) {
			returnValue = surfaces[j];
			break;
		}
	}

	return returnValue;
}

int32 APRM::generateVertex(int32 startID, ASurfaceArea* surface, float agentSize) {
	//For the sake of preventing infinite loops
	int32 tries = 0;
	int32 newID = startID;

	//Generate the vertex
	AVertex* newVertex = nullptr;

	//As long as the new vertex is not created, try to create one
	while (newVertex == nullptr && tries < 100) {
		newVertex = surface->generateVertex(newID, agentSize, false);
		tries++;
	}

	//If no vertex is created at all, generate a vertex in the middle of the surface if possible
	if (newVertex == nullptr) { newVertex = surface->generateVertexAtLocation(newID, agentSize, surface->GetActorLocation(), true); }

	//Add the new vertex to the vertices array and increase the id, if a new vertex has been created
	if (newVertex != nullptr) {
		vertices.AddUnique(newVertex);
		newID++;
	}

	return newID;
}

int32 APRM::generateVertexAtLocation(int32 startID, ASurfaceArea* surface, FVector location, float agentSize)
{
	//For the sake of preventing infinite loops
	int32 tries = 0;
	int32 newID = startID;

	//Generate the vertex
	AVertex* newVertex = surface->generateVertexAtLocation(newID, agentSize, location, true);

	//Add the new vertex to the vertices array and increase the id, if a new vertex has been created
	if (newVertex != nullptr) {
		vertices.AddUnique(newVertex);
		newID++;
	}

	return newID;
}

int32 APRM::generateVertexInSubsurface(int32 startID, ASurfaceArea* surface, int32 index, float agentSize) {
	//For the sake of preventing infinite loops
	int32 tries = 0;
	int32 newID = startID;

	//Generate the vertex
	AVertex* newVertex = nullptr;

	//As long as the new vertex is not created, try to create one
	while (newVertex == nullptr && tries < 100) {
		newVertex = surface->generateVertexInSubsurface(newID, agentSize, index, false);
		tries++;
	}

	//If no vertex is created at all, generate a vertex in the middle of the subsurface if possible
	if (newVertex == nullptr) {
		if (surface->cubes.IsValidIndex(index)) { newVertex = surface->generateVertexAtLocation(newID, agentSize, surface->cubes[index]->GetComponentLocation(), true); }
	}

	if (newVertex != nullptr) {
		vertices.AddUnique(newVertex);
		newID++;
	}

	return newID;
}

int32 APRM::generateEdges(int32 startID, float agentSize, TArray<FPRMConnection> inConnections, TArray<FPRMConnection> &outConnections, bool knn, bool knn3d) {
	int edgeID = startID;
	outConnections = inConnections;

	//Indicate that no vertex has been checked yet
	TArray<AVertex*> checkedVertices = {};
	TArray<AVertex*> uncheckedVertices;
	for (AVertex* vertex : vertices) { uncheckedVertices.AddUnique(vertex);	}

	//Add edges to every vertex
	for (AVertex* vertex : vertices) {
		if (uncheckedVertices.Num() > 0) {
			//Pick the first vertex in the vertex array, which is different for every loop
			AVertex* baseVertex = uncheckedVertices[0];
			baseVertex->possibleNeighbours.Empty();
			uncheckedVertices.Remove(baseVertex);
			TArray<AVertex*> possibleNeighbours;
			
			//Find either all vertices in a close area, or the K-nearest neighbours on the plane, or the K-nearest neighbours in 3D
			if (knn3d) {
				TArray<AVertex*> empty;

				//Find the extent of the overlap box to check for neighbours
				FVector extent = FVector(5000);
				possibleNeighbours = findAllNearbyNeighbours(baseVertex, extent, empty);

				//Sort the neighbours so that the nearest neighbour is first in the array
				Algo::SortBy(possibleNeighbours, [&](AVertex* vertexA)
				{
					const float& distance = (vertexA->GetActorLocation() - baseVertex->GetActorLocation()).Size();
					return distance;
				});

				int32 edgesGenerated = 0;

				//Create an edge between two vertices if not blocked and not over a hole. Also make sure, since it's KNN, that 
				if (edgesGenerated < edgeCount3D) {
					for (AVertex* neighbour : possibleNeighbours) {
						//Direct connection between two vertices on the same plane (the surfaces of this PRM)
						if (!isEdgeBlocked(baseVertex, neighbour, agentSize) && !isEdgeOverVoid(baseVertex->GetActorLocation(), neighbour->GetActorLocation())) {
							if (!doesEdgeExist(baseVertex, neighbour)) {
								generateEdge(baseVertex, neighbour, edgeID, baseVertex->surface, false);
								edgeID++;
							}
							edgesGenerated++;
						}
						//If the vertices are not on the same PRM and they are not helper vertices, connect them later on and for now indicate that they should be connected.
						else if (!vertices.Contains(neighbour) && neighbour->GetClass() != AHelperVertex::StaticClass()) {
							//Check if the neighbour is in a neighbouring surface
							if (checkNeighbouringSurfaces(baseVertex, neighbour)) {
								FPRMConnection connection = FPRMConnection(baseVertex, neighbour);
								outConnections.Add(connection);
								edgesGenerated++;
								baseVertex->possibleNeighbours.AddUnique(neighbour->id);
							}
						}

						//If enough edges have been generated, stop trying to generate more
						if (edgesGenerated >= edgeCount3D) { break; }
					}
				}
			}
			else if (knn) {
				TArray<AVertex*> empty;

				//Find the extent of the overlap box to check for neighbours
				FVector extent = FVector(7500);
				switch (baseVertex->surface) {
				case ESurfaceType::Floor:
					extent.Z = 10;
					break;
				case ESurfaceType::Ceiling:
					extent.Z = 10;
					break;
				case ESurfaceType::NorthWall:
					extent.X = 10;
					break;
				case ESurfaceType::SouthWall:
					extent.X = 10;
					break;
				case ESurfaceType::EastWall:
					extent.Y = 10;
					break;
				case ESurfaceType::WestWall:
					extent.Y = 10;
					break;
				case ESurfaceType::Stairs:
					extent.Z = 10;
					break;
				case ESurfaceType::StairsCeiling:
					extent.Z = 10;
					break;
				default:
					break;
				}
				possibleNeighbours = findAllNearbyNeighbours(baseVertex, extent, empty);

				//Sort the neighbours so that the nearest neighbour is first in the array
				Algo::SortBy(possibleNeighbours, [&](AVertex* vertexA)
				{
					const float& distance = (vertexA->GetActorLocation() - baseVertex->GetActorLocation()).Size();
					return distance;
				});

				int32 edgesGenerated = 0;

				//Create an edge between two vertices if not blocked and not over a hole. Also make sure, since it's KNN, that 
				if (edgesGenerated < edgeCount) {
					for (AVertex* neighbour : possibleNeighbours) {
						if (!isEdgeBlocked(baseVertex, neighbour, agentSize) && !isEdgeOverVoid(baseVertex->GetActorLocation(), neighbour->GetActorLocation())) {
							if (!doesEdgeExist(baseVertex, neighbour)) {
								generateEdge(baseVertex, neighbour, edgeID, baseVertex->surface, false);
								edgeID++;
							}
							edgesGenerated++;
						}

						//If enough edges have been generated, stop trying to generate more
						if (edgesGenerated >= edgeCount) { break; }
					}
				}
			}
			else {
				//Find the extent of the overlap box to check for neighbours
				FVector extent = FVector(750);
				switch (baseVertex->surface) {
				case ESurfaceType::Floor:
					extent.Z = 10;
					break;
				case ESurfaceType::Ceiling:
					extent.Z = 10;
					break;
				case ESurfaceType::NorthWall:
					extent.X = 10;
					break;
				case ESurfaceType::SouthWall:
					extent.X = 10;
					break;
				case ESurfaceType::EastWall:
					extent.Y = 10;
					break;
				case ESurfaceType::WestWall:
					extent.Y = 10;
					break;
				case ESurfaceType::Stairs:
					extent.Z = 10;
					break;
				case ESurfaceType::StairsCeiling:
					extent.Z = 10;
					break;
				default:
					break;
				}
				possibleNeighbours = findAllNearbyNeighbours(baseVertex, extent, checkedVertices);

				//Create an edge between two vertices if not blocked and not over a hole
				for (AVertex* neighbour : possibleNeighbours) {
					if (!isEdgeBlocked(baseVertex, neighbour, agentSize) && !isEdgeOverVoid(baseVertex->GetActorLocation(), neighbour->GetActorLocation())) {
						generateEdge(baseVertex, neighbour, edgeID, baseVertex->surface, false);
						edgeID++;
					}
				}
			}

			//The base vertex does not need to be checked anymore
			checkedVertices.AddUnique(baseVertex);
		}
	}

	return edgeID;
}

TArray<AVertex*> APRM::findAllNearbyNeighbours(AVertex* baseVertex, FVector extent, TArray<AVertex*> checkedVertices) {
	//Overlapped vertices
	TArray<AVertex*> returnValue;
	TArray<AActor*> tempActors;
	
	//Actors to ignore, so the vertex itself
	TArray<AActor*> ignores;
	ignores.Add(baseVertex);
	ignores.Append(checkedVertices);

	//Object types to trace
	TArray<TEnumAsByte<EObjectTypeQuery>> traceObjectTypes;
	traceObjectTypes.Add(UEngineTypes::ConvertToObjectType(ECollisionChannel::ECC_WorldStatic));

	//Find all vertices overlapping the cube
	UKismetSystemLibrary::BoxOverlapActors(GetWorld(), baseVertex->GetActorLocation(), extent, traceObjectTypes, AVertex::StaticClass(), ignores, tempActors);

	//Cast to vertices and add to the result array
	for (AActor* actor : tempActors) { returnValue.AddUnique((AVertex*)actor); }

	return returnValue;
}

bool APRM::isEdgeBlocked(AVertex* a, AVertex* b, float agentSize) {
	//Start and end of the trace
	FVector traceStartBase = a->GetActorLocation();
	FVector traceEndBase = b->GetActorLocation();
	FVector traceStart = traceStartBase;
	FVector traceEnd = traceEndBase;
	float offset = agentSize - 4;

	//Add an offset to the start and end points such that the surface that the vertices are on are not used in computing whether there is a blocked edge
	switch (a->surface) {
	case ESurfaceType::Floor:
		traceStart += FVector(0, 0, offset);
		break;
	case ESurfaceType::Ceiling:
		traceStart += FVector(0, 0, -offset);
		break;
	case ESurfaceType::NorthWall:
		traceStart += FVector(-offset, 0, 0);
		break;
	case ESurfaceType::SouthWall:
		traceStart += FVector(offset, 0, 0);
		break;
	case ESurfaceType::EastWall:
		traceStart += FVector(0, -offset, 0);
		break;
	case ESurfaceType::WestWall:
		traceStart += FVector(0, offset, 0);
		break;
	case ESurfaceType::Stairs:
		traceStart += FVector(0, 0, offset);
		break;
	case ESurfaceType::StairsCeiling:
		traceStart += FVector(0, 0, -offset);
		break;
	default:
		break;
	}
	switch (b->surface) {
	case ESurfaceType::Floor:
		traceEnd += FVector(0, 0, offset);
		break;
	case ESurfaceType::Ceiling:
		traceEnd += FVector(0, 0, -offset);
		break;
	case ESurfaceType::NorthWall:
		traceEnd += FVector(-offset, 0, 0);
		break;
	case ESurfaceType::SouthWall:
		traceEnd += FVector(offset, 0, 0);
		break;
	case ESurfaceType::EastWall:
		traceEnd += FVector(0, -offset, 0);
		break;
	case ESurfaceType::WestWall:
		traceEnd += FVector(0, offset, 0);
		break;
	case ESurfaceType::Stairs:
		traceEnd += FVector(0, 0, offset);
		break;
	case ESurfaceType::StairsCeiling:
		traceEnd += FVector(0, 0, -offset);
		break;
	default:
		break;
	}

	//Output array
	FHitResult roomHit;
	TArray<FHitResult> vertexHits;

	//Actors to ignore
	TArray<AActor*> ignores;

	//Object types to trace
	TArray<TEnumAsByte<EObjectTypeQuery>> traceObjectTypesLine;
	traceObjectTypesLine.Add(UEngineTypes::ConvertToObjectType(ECollisionChannel::ECC_WorldStatic));

	//Do a box trace from a to b with the size of the mobile agent
	UKismetSystemLibrary::BoxTraceSingleByProfile(GetWorld(), traceStart, traceEnd, FVector(agentSize), FRotator(0), "EdgeTraceBlocker", false, ignores, EDrawDebugTrace::None, roomHit, true, FLinearColor::Blue, FLinearColor::Green, 60);
	UKismetSystemLibrary::LineTraceMultiForObjects(GetWorld(), traceStartBase, traceEndBase, traceObjectTypesLine, true, ignores, EDrawDebugTrace::None, vertexHits, true, FLinearColor::Yellow, FLinearColor::Red, 60);

	//Check whether a room has been hit
	if (IsValid(roomHit.GetActor())) {
		if (roomHit.GetActor()->GetClass() == ABasicRoom::StaticClass()) { return true; }
	}

	//Check whether a vertex has been hit
	for (FHitResult hit : vertexHits) {
		//Check that there is a hit with an actor
		if (IsValid(hit.GetActor()))
		{
			//If the hit is a vertex, check if it's b, which a should connect to.
			if (hit.GetActor()->GetClass() == AVertex::StaticClass() || hit.GetActor()->GetClass() == AHelperVertex::StaticClass()) { return !(hit.GetActor() == b); }
		}
	}

	// This area should not be reached in theory, but if so, it means vertex b is not found and thus the edge should not be generated
	return true;
}

bool APRM::isFutureEdgeBlocked(FVector a, FVector b, ESurfaceType surfaceA, ESurfaceType surfaceB, float agentSize)
{//Start and end of the trace
	FVector traceStart = a;
	FVector traceEnd = b;
	float offset = 5;

	//Add an offset to the start and end points such that the surface that the vertices are on are not used in computing whether there is a blocked edge
	switch (surfaceA) {
	case ESurfaceType::Floor:
		traceStart += FVector(0, 0, offset);
		traceEnd += FVector(0, 0, offset);
		break;
	case ESurfaceType::Ceiling:
		traceStart += FVector(0, 0, -offset);
		traceEnd += FVector(0, 0, -offset);
		break;
	case ESurfaceType::NorthWall:
		traceStart += FVector(-offset, 0, 0);
		traceEnd += FVector(-offset, 0, 0);
		break;
	case ESurfaceType::SouthWall:
		traceStart += FVector(offset, 0, 0);
		traceEnd += FVector(offset, 0, 0);
		break;
	case ESurfaceType::EastWall:
		traceStart += FVector(0, -offset, 0);
		traceEnd += FVector(0, -offset, 0);
		break;
	case ESurfaceType::WestWall:
		traceStart += FVector(0, offset, 0);
		traceEnd += FVector(0, offset, 0);
		break;
	case ESurfaceType::Stairs:
		traceStart += FVector(0, 0, offset);
		traceEnd += FVector(0, 0, offset);
		break;
	case ESurfaceType::StairsCeiling:
		traceStart += FVector(0, 0, -offset);
		traceEnd += FVector(0, 0, -offset);
		break;
	default:
		break;
	}

	//Output array
	FHitResult roomHit;
	TArray<FHitResult> vertexHits;

	//Actors to ignore
	TArray<AActor*> ignores;

	//Object types to trace
	TArray<TEnumAsByte<EObjectTypeQuery>> traceObjectTypesLine;
	traceObjectTypesLine.Add(UEngineTypes::ConvertToObjectType(ECollisionChannel::ECC_WorldStatic));

	//Do a box trace from a to b with the size of the mobile agent
	UKismetSystemLibrary::BoxTraceSingleByProfile(GetWorld(), traceStart, traceEnd, FVector(agentSize), FRotator(0), "EdgeTraceBlocker", false, ignores, EDrawDebugTrace::None, roomHit, true, FLinearColor::Blue, FLinearColor::Green, 60);
	
	//Check whether a room has been hit
	if (IsValid(roomHit.GetActor())) {
		if (roomHit.GetActor()->GetClass() == ABasicRoom::StaticClass()) { return true; }
	}

	return false;
}

//MAY NOT BE NEEDED SINCE THERE IS ONLY ONE DIFFERENCE BETWEEN THIS AND ISEDGEBLOCKED
bool APRM::isEdgeBlockedHelper(AVertex* a, AVertex* b, float agentSize) {
	//Start and end of the trace
	FVector traceStartBase = a->GetActorLocation();
	FVector traceEndBase = b->GetActorLocation();
	FVector traceStart = traceStartBase;
	FVector traceEnd = traceEndBase;
	float offset = 5;

	//Add an offset to the start and end points such that the surface that the vertices are on are not used in computing whether there is a blocked edge
	switch (a->surface) {
	case ESurfaceType::Floor:
		traceStart += FVector(0, 0, offset);
		traceEnd += FVector(0, 0, offset);
		break;
	case ESurfaceType::Ceiling:
		traceStart += FVector(0, 0, -offset);
		traceEnd += FVector(0, 0, -offset);
		break;
	case ESurfaceType::NorthWall:
		traceStart += FVector(-offset, 0, 0);
		traceEnd += FVector(-offset, 0, 0);
		break;
	case ESurfaceType::SouthWall:
		traceStart += FVector(offset, 0, 0);
		traceEnd += FVector(offset, 0, 0);
		break;
	case ESurfaceType::EastWall:
		traceStart += FVector(0, -offset, 0);
		traceEnd += FVector(0, -offset, 0);
		break;
	case ESurfaceType::WestWall:
		traceStart += FVector(0, offset, 0);
		traceEnd += FVector(0, offset, 0);
		break;
	case ESurfaceType::Stairs:
		traceStart += FVector(0, 0, offset);
		traceEnd += FVector(0, 0, offset);
		break;
	case ESurfaceType::StairsCeiling:
		traceStart += FVector(0, 0, -offset);
		traceEnd += FVector(0, 0, -offset);
		break;
	default:
		break;
	}

	//Output array
	FHitResult roomHit;
	TArray<FHitResult> vertexHits;

	//Actors to ignore
	TArray<AActor*> ignores;

	//Object types to trace
	TArray<TEnumAsByte<EObjectTypeQuery>> traceObjectTypesLine;
	traceObjectTypesLine.Add(UEngineTypes::ConvertToObjectType(ECollisionChannel::ECC_WorldStatic));

	//Do a box trace from a to b with the size of the mobile agent
	UKismetSystemLibrary::BoxTraceSingleByProfile(GetWorld(), traceStart, traceEnd, FVector(agentSize), FRotator(0), "EdgeTraceBlocker", false, ignores, EDrawDebugTrace::None, roomHit, true, FLinearColor::Blue, FLinearColor::Green, 60);
	UKismetSystemLibrary::LineTraceMultiForObjects(GetWorld(), traceStartBase, traceEndBase, traceObjectTypesLine, true, ignores, EDrawDebugTrace::None, vertexHits, true, FLinearColor::Yellow, FLinearColor::Red, 60);
	
	//Check whether a room has been hit
	if (IsValid(roomHit.GetActor())) {
		if (roomHit.GetActor()->GetClass() == ABasicRoom::StaticClass()) { return true; }
	}

	//Check whether a vertex has been hit
	for (FHitResult hit : vertexHits) {
		//Check that there is a hit with an actor
		if (IsValid(hit.GetActor()))
		{
			//If the hit is a vertex, check if it's b, which a should connect to.
			if (hit.GetActor()->GetClass() == AVertex::StaticClass() || hit.GetActor()->GetClass() == AHelperVertex::StaticClass()) { return !(hit.GetActor() == b); }
		}
	}
	// This area should not be reached in theory, but if so, it means vertex b is not found and thus the edge should not be generated
	return true;
}

bool APRM::isEdgeDoubleBlocked(AVertex* a, AVertex* b, float agentSize) {
	//Start and end of the trace
	FVector traceStartBase = a->GetActorLocation();
	FVector traceEndBase = b->GetActorLocation();
	FVector traceStart = traceStartBase;
	FVector traceEnd = traceEndBase;
	float offset = agentSize - 4;

	//Add an offset to the start and end points such that the surface that the vertices are on are not used in computing whether there is a blocked edge
	switch (a->surface) {
	case ESurfaceType::Floor:
		traceStart += FVector(0, 0, offset);
		traceEnd += FVector(0, 0, offset);
		break;
	case ESurfaceType::Ceiling:
		traceStart += FVector(0, 0, -offset);
		traceEnd += FVector(0, 0, -offset);
		break;
	case ESurfaceType::NorthWall:
		traceStart += FVector(-offset, 0, 0);
		traceEnd += FVector(-offset, 0, 0);
		break;
	case ESurfaceType::SouthWall:
		traceStart += FVector(offset, 0, 0);
		traceEnd += FVector(offset, 0, 0);
		break;
	case ESurfaceType::EastWall:
		traceStart += FVector(0, -offset, 0);
		traceEnd += FVector(0, -offset, 0);
		break;
	case ESurfaceType::WestWall:
		traceStart += FVector(0, offset, 0);
		traceEnd += FVector(0, offset, 0);
		break;
	case ESurfaceType::Stairs:
		traceStart += FVector(0, 0, offset);
		traceEnd += FVector(0, 0, offset);
		break;
	case ESurfaceType::StairsCeiling:
		traceStart += FVector(0, 0, -offset);
		traceEnd += FVector(0, 0, -offset);
		break;
	default:
		break;
	}

	//Output array
	TArray<FHitResult> roomHits;
	TArray<FHitResult> vertexHits;

	//Actors to ignore
	TArray<AActor*> ignores;

	//Object types to trace
	TArray<TEnumAsByte<EObjectTypeQuery>> traceObjectTypesLine;
	traceObjectTypesLine.Add(UEngineTypes::ConvertToObjectType(ECollisionChannel::ECC_WorldStatic));

	//Do a box trace from a to b with the size of the mobile agent
	UKismetSystemLibrary::BoxTraceMultiByProfile(GetWorld(), traceStart, traceEnd, FVector(agentSize), FRotator(0), "EdgeTraceBlocker", false, ignores, EDrawDebugTrace::None, roomHits, true, FLinearColor::Blue, FLinearColor::Green, 60);
	UKismetSystemLibrary::LineTraceMultiForObjects(GetWorld(), traceStartBase, traceEndBase, traceObjectTypesLine, true, ignores, EDrawDebugTrace::None, vertexHits, true, FLinearColor::Yellow, FLinearColor::Red, 60);

	//Check whether a room has been hit
	int32 hits = 0;
	for (FHitResult roomHit : roomHits) {
		if (IsValid(roomHit.GetActor())) {
			if (roomHit.GetActor()->GetClass() == ABasicRoom::StaticClass()) { hits++; }
		}
	}

	if (hits > 3) { return true; }

	//Check whether a vertex has been hit
	for (FHitResult hit : vertexHits) {
		//Check that there is a hit with an actor
		if (IsValid(hit.GetActor()))
		{
			//If the hit is a vertex, check if it's b, which a should connect to.
			if (hit.GetActor()->GetClass() == AVertex::StaticClass()) {	return !(hit.GetActor() == b); }
		}
	}
	// This area should not be reached in theory, but if so, it means vertex b is not found and thus the edge should not be generated
	return true;
}

bool APRM::isEdgeDoubleBlockedHelper(AVertex* a, AVertex* b, float agentSize) {
	//Start and end of the trace
	FVector traceStartBase = a->GetActorLocation();
	FVector traceEndBase = b->GetActorLocation();
	FVector traceStart = traceStartBase;
	FVector traceEnd = traceEndBase;
	float offset = 5;

	//Add an offset to the start and end points such that the surface that the vertices are on are not used in computing whether there is a blocked edge
	switch (a->surface) {
	case ESurfaceType::Floor:
		traceStart += FVector(0, 0, offset);
		traceEnd += FVector(0, 0, offset);
		break;
	case ESurfaceType::Ceiling:
		traceStart += FVector(0, 0, -offset);
		traceEnd += FVector(0, 0, -offset);
		break;
	case ESurfaceType::NorthWall:
		traceStart += FVector(-offset, 0, 0);
		traceEnd += FVector(-offset, 0, 0);
		break;
	case ESurfaceType::SouthWall:
		traceStart += FVector(offset, 0, 0);
		traceEnd += FVector(offset, 0, 0);
		break;
	case ESurfaceType::EastWall:
		traceStart += FVector(0, -offset, 0);
		traceEnd += FVector(0, -offset, 0);
		break;
	case ESurfaceType::WestWall:
		traceStart += FVector(0, offset, 0);
		traceEnd += FVector(0, offset, 0);
		break;
	case ESurfaceType::Stairs:
		traceStart += FVector(0, 0, offset);
		traceEnd += FVector(0, 0, offset);
		break;
	case ESurfaceType::StairsCeiling:
		traceStart += FVector(0, 0, -offset);
		traceEnd += FVector(0, 0, -offset);
		break;
	default:
		break;
	}

	//Output array
	TArray<FHitResult> roomHits;
	TArray<FHitResult> vertexHits;

	//Actors to ignore
	TArray<AActor*> ignores;

	//Object types to trace
	TArray<TEnumAsByte<EObjectTypeQuery>> traceObjectTypesLine;
	traceObjectTypesLine.Add(UEngineTypes::ConvertToObjectType(ECollisionChannel::ECC_WorldStatic));

	//Do a box trace from a to b with the size of the mobile agent
	UKismetSystemLibrary::BoxTraceMultiByProfile(GetWorld(), traceStart, traceEnd, FVector(agentSize), FRotator(0), "EdgeTraceBlocker", false, ignores, EDrawDebugTrace::None, roomHits, true, FLinearColor::Blue, FLinearColor::Green, 60);
	UKismetSystemLibrary::LineTraceMultiForObjects(GetWorld(), traceStartBase, traceEndBase, traceObjectTypesLine, true, ignores, EDrawDebugTrace::None, vertexHits, true, FLinearColor::Yellow, FLinearColor::Red, 60);
	
	//Check whether a room has been hit
	int32 hits = 0;
	for (FHitResult roomHit : roomHits) {
		if (IsValid(roomHit.GetActor())) {
			if (roomHit.GetActor()->GetClass() == ABasicRoom::StaticClass()) { hits++; }
		}
	}

	if (hits > 3) { return true; }

	//Check whether a vertex has been hit
	for (FHitResult hit : vertexHits) {
		//Check that there is a hit with an actor
		if (IsValid(hit.GetActor()))
		{
			//If the hit is a vertex, check if it's b, which a should connect to.
			if (hit.GetActor()->GetClass() == AVertex::StaticClass() || hit.GetActor()->GetClass() == AHelperVertex::StaticClass()) {
				return !(hit.GetActor() == b);
			}
		}
	}
	// This area should not be reached in theory, but if so, it means vertex b is not found and thus the edge should not be generated
	return true;
}

bool APRM::doesEdgeExist(AVertex* a, AVertex* b)
{
	if (a == nullptr || b == nullptr) { return true; }
	return a->neighbours.Contains(b->id);
}

bool APRM::isEdgeOverVoid(FVector traceStart, FVector traceEnd) {
	//Surfaces hit by the trace
	TArray<FHitResult> hitsAB;
	TArray<FHitResult> hitsBA;
	
	//Actors to ignore
	TArray<AActor*> ignores;

	//Object types to trace
	TArray<TEnumAsByte<EObjectTypeQuery>> traceObjectTypesLine;
	traceObjectTypesLine.Add(UEngineTypes::ConvertToObjectType(ECollisionChannel::ECC_WorldStatic));

	//Do the line trace in two directions
	UKismetSystemLibrary::LineTraceMultiForObjects(GetWorld(), traceStart, traceEnd, traceObjectTypesLine, true, ignores, EDrawDebugTrace::None, hitsAB, true, FLinearColor::Yellow, FLinearColor::Red, 60);
	UKismetSystemLibrary::LineTraceMultiForObjects(GetWorld(), traceEnd, traceStart, traceObjectTypesLine, true, ignores, EDrawDebugTrace::None, hitsBA, true, FLinearColor::Red, FLinearColor::Yellow, 60);

	TArray<FHitResult> surfaceHitsAB;
	TArray<FHitResult> surfaceHitsBA;

	//Make sure to find all hits that belong to surfaces, excluding connection cube hits
	for (FHitResult hit : hitsAB) { 
		if (hit.GetActor()->GetClass() == ASurfaceArea::StaticClass()) {
			ASurfaceArea* hitSurface = (ASurfaceArea*) hit.GetActor();

			bool addHit = true;
			for (UStaticMeshComponent* hitConnector : hitSurface->connectionCubes) {
				if (hit.GetComponent() == hitConnector) { addHit = false; }
			}

			if (addHit) { surfaceHitsAB.Add(hit); }
		} 
	}

	for (FHitResult hit : hitsBA) { 
		if (hit.GetActor()->GetClass() == ASurfaceArea::StaticClass()) {
			ASurfaceArea* hitSurface = (ASurfaceArea*)hit.GetActor();

			bool addHit = true;
			for (UStaticMeshComponent* hitConnector : hitSurface->connectionCubes) {
				if (hit.GetComponent() == hitConnector) { addHit = false; }
			}

			if (addHit) { surfaceHitsBA.Add(hit); }
		} 
	}

	//Check all hits of trace ab to see if the impact points are the same as the impact points of trace ba in reverse order (approximately)
	for (int i = 0; i < surfaceHitsAB.Num(); i++){
		//Ensure that the index j is always in range
		int j = surfaceHitsBA.Num() - i - 1;
		
		if (j >= 0) {
			// Check that the impact point of ab is the same as the reverse impact point of ba. If not, there is a hole, so return true
			if (!surfaceHitsAB[i].ImpactPoint.Equals(surfaceHitsBA[j].ImpactPoint, 1)) { return true; }
		}
	}

	//No hole is found
	return false;
}

APRMEdge* APRM::generateEdge(AVertex* a, AVertex* b, int32 ID, ESurfaceType surfaceType, bool showEdge) {
	//Create an edge between each pair of vertices, give the edge and ID and add the edge to the graph
	if (a != b) {
		APRMEdge* newEdge = GetWorld()->SpawnActor<APRMEdge>(a->GetActorLocation(), FRotator(0), FActorSpawnParameters());

		//If the edge is somehow non-existent, just return a nullpointer
		if (newEdge == nullptr) { return nullptr; }

		//Give the edge an ID
		newEdge->id = ID;

		//Set the vertices as end points of the edge
		newEdge->endVertices.AddUnique(a->id);
		newEdge->endVertices.AddUnique(b->id);

		//Set the surface the edge is on
		newEdge->surface = surfaceType;
		newEdge->setEdge(a->GetActorLocation(), b->GetActorLocation());

		//Shape the edge
		if (showEdge) { newEdge->showEdge(); }
		else { newEdge->hideEdge(); }

		//Set the two vertices as neighbours
		a->neighbours.AddUnique(b->id);
		b->neighbours.AddUnique(a->id);

		//Add the edge to the array for this PRM
		edges.AddUnique(newEdge);

		return newEdge;
	}

	//We don't allow selfloops, so we return a nullpointer if the two vertices are the same
	return nullptr;
}

bool APRM::isNeighbour(int32 neighbourID) {
	for (FPRMNeighbour neighbour : neighbours) {
		if (neighbour.neighbourID == neighbourID) {
			return true;
		}
	}
	return false;
}

FPRMNeighbour APRM::getNeighbourFromID(int32 neighbourID) {
	for (FPRMNeighbour neighbour : neighbours) {
		if (neighbour.neighbourID == neighbourID) { return neighbour; }
	}

	return FPRMNeighbour();
}

ASurfaceArea* APRM::getSurfaceFromStruct(FPRMNeighbour neighbour) {
	for (ASurfaceArea* surface : surfaces) {
		if (surface->id == neighbour.surfaceID) {
			return surface;
		}
	}
	return nullptr;
}

ASurfaceArea* APRM::getNeighbourSurfaceFromStruct(APRM* b, FPRMNeighbour neighbour) {
	for (ASurfaceArea* surface : b->surfaces) {
		if (surface->id == neighbour.neighbourSurfaceID) {
			return surface;
		}
	}
	return nullptr;
}

FPRMConnection::FPRMConnection()
{
}

FPRMConnection::FPRMConnection(AVertex * inVertexA, AVertex* inVertexB)
{
	vertexA = inVertexA;
	vertexB = inVertexB;
}
